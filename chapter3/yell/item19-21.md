# 3장. 타입 추론

타입스크립트는 타입 추론을 적극적으로 수행한다. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여 주기 때문에, 코드의 전체적인 안정성이 향상된다.

### 3장을 읽은 후에는 기대할 수 있는 효과

- 타입스크립트가 어떻게 타입을 추론하는지
- 언제 타입 선언을 작성해야 하는지
- 타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는 것이 필요한 상황은 언제인지

<br/>
<br/>

## 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

자바스크립트를 사용하다가 타입스크립트를 처음 접한 개발자가 사용할 때는 변수를 선언할 때마다 타입을 명시해야 한다고 생각한다. 그러나 타입스크립트의 많은 타입 구문은 사실 불필요.

<br/>

### 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다.

```ts
let x: number = 12;

let x = 12; // 이렇게만 선언해도 타입스크립트는 변수 x의 타입을 number로 추론할 수 있다.
```

<br/>
 
### 타입이 추론되면 리팩터링이 용이해진다.

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(id, name, price);
}

// 위처럼 쓰는 것보다 아래처럼 매개변수 product를 비구조화 할당문으로 사용해서 구현하는 게 낫다.
// 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다.
function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다. 그리고 함수 매개변수에 타입 구문을 생략하는 경우도 간혹 있다.

```ts
function parseNumber(str: string, base = 10) {
  // base의 기본 값이 10이기 때문에 타입은 number로 추론된다.
}
```

<br/>

### 타입이 추론될 수 있음에도 여전히 타입을 명시하고 싶은 상황

- 객체 리터럴을 정의할 때

```ts
const elmo = {
  name: "Tickle Me Elmo",
  id: "048188 627152",
  price: 28.99,
};

logProduct(elmo); // 여기에서 타입에러가 발생
```

그러나 타입 구문을 제대로 명시한다면, 실제로 실수가 발생한 부분에 오류를 표시해 준다.

```ts
const elmo: Product = {
  name: "Tickle Me Elmo",
  id: "048188 627152", // 여기에서 타입에러가 발생, string 형식은 number 형식에 할당할 수 없습니다.
  price: 28.99,
};

logProduct(elmo);
```

<br/>

- 함수의 반환에 타입을 명시

  - 반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.
  - 함수에 대해 더욱 명확하게 알 수 있다. 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야 하고, 함수를 구현 하기 전에 테스트를 먼저 작성하는 테스트 주도 개발(TDD)과 비슷하다.
  - 반환값의 타입을 명시해야 하는 또 다른 이유는 명명된 타입을 사용하기 위해서이다.

  ```ts
  interface Vector2D {
    x: number;
    y: number;
  }
  function add(a: Vector2D, b: Vector2D) {
    return { x: a.x + b.x, y: a.y + b.y };
  }

  add(); // add(a: Vector2D, b: Vector2D): {x: number; y: number;}
  ```

  위의 `add`함수에서 반환 타입을 `{x: number; y: number;}`로 추론했다. 입력이 `Vector2D`인데 출력은 `Vector2D`가 아니기 때문에 사용자 입장에서는 당황스러울 수 있다.

<br/>
<br/>

## 아이템 20. 다른 타입에는 다른 변수 사용하기

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 되지만, 타입스크립트에서는 **변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다**.

<br/>

### 다른 타입에는 별도의 변수를 사용하는 게 바람직한 이유

- 서로 관련이 없는 두 개의 값을 분리
- 변수명을 더 구체적으로 지을 수 있다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해진다.
- 타입이 좀 더 간결해진다.
- `let` 대신 `const`로 변수를 선언하게 된다.

<br/>
<br/>

## 아이템 21. 타입 넓히기

> 이번 아이템의 제목은 조금 잘못되지 않았나 싶다. `타입 넓히기`가 아니라 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해하고 제대로 추론할 수 있도록 `타입 추론을 제어하고 좁히기`로 되어야 하지 않을까 싶다.

<br/>

```ts
interface Vector3D {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3D, axis: "x" | "y" | "z") {
  return vector[axis];
}

let x = "x";
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // 함수가 받은 매개변수 x에서 타입에러 발생, 'string' 형식의 인수는 'x' | 'y' | 'z' 형식의 매개변수에 할당할 수 없습니다.
```

<br/>

### 타입스크립트에서 넓히기의 과정을 제어하기

- `const` 사용

```ts
const x = "x";
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x);
```

변수 `x`를 선언할 때 `let` 대신 `const`를 사용하면 `x`의 값이 `'x'`로 고정되므로 함수호출시에 타입에러가 발생하지 않는다.

<br/>

그러나 `const`는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 발생할 수 있다. 그래서 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다. **타입스크립트의 기본 동작을 재정의**하는 세 가지 방법이 있다.

### 1. 명시적 타입 구문을 제공

```ts
const v: { x: 1 | 3 | 5 } = {
  x: 1,
}; // 객체 v에서 키 x가 가질 수 있는 값은 1, 3, 또는 5로 제어된다.
```

<br/>

### 2. 타입 체커에 추가적인 문맥을 제공

예를 들어, 함수의 매개변수로 값을 전달하는 것이 있는데 특정 부분에서 추론이 되지 않으니 문맥을 제공해야 한다.

```ts
export default function App() {
  const handleClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
    console.log(e.target);
    alert("You clicked the button!");
  };

  return <button onClick={(e) => handleClick(e)}>click me!</button>;
}
```

`button` 안에서 쓰이는 `onClick`에 직접 함수를 정의해주었을 때에는 `e`가 무엇인지 알 수 있으나, 그 밖에서 함수를 정의해서 쓸 때는 `e`의 타입이 무엇인지 모르기 때문이다. 그러므로 함수 `handleClick`에서 받는 매개변수 e에 추가적인 문맥을 제공하지 않으면 타입에러가 발생하므로 다음과 같이 `e`의 타입이 무엇인지 추가적인 문맥을 제공해야 한다.

<br/>

### 3. `const` 단언문의 사용

```ts
const v1 = { x: 1, y: 2 }; // 타입은 { x: number; y: number; }
const v2 = { x: 1 as const, y: 2 }; // 타입은 { x: 1; y: number; }
const v3 = { x: 1, y: 2 } as const; // 타입은 { readonly x: 1; readonly y: 2; }

const a1 = [1, 2, 3]; // 타입이 number[]
const a2 = [1, 2, 3] as const; // 타입이 readonly [1, 2, 3]
```

<br/>

넓히기로 인해 오류가 발생한다고 생각되면, **명시적 타입 구문 또는 const 단언문을 추가하는 것을 고려**해야 한다.
