# Chapter 3

> 타입추론에서 발생할 수있는 문제와 해법.

- TS 의 타입추론 방법,
- 타입 선언을 작성해야하는 때 이해
- 명시적 타입 선언이 필요한 상황 이해.

# Item 19 - 추론 가능한 타입을 사용해 장황한 코드 방지하기.

> 모든 변수에 타입을 선언하는 것은 비 생산적이다.

타입이 추론된다면 명시적 타입 구문작성은 오히려 방해만 된다.

가령

```JS
interface Product {

id:number;

name:string;

price:number;

}



function logProduct(product:Product){

const id:number = product.id;

const name:string =product.name;

const price:number = product.price;

}
```

코드가 있을 때, Product 의 id 타입이 string 으로 변하면
에러를 뱉어낸다.

오히려 타입 추론을 사용하는 것이 이 경우 용이하다.

```JS
function logProduct(product:Product){
	const {id,name,price} = product;
}
```

이렇게 비구조화 할당문을 사용하여 구현하는 것이 더 낫다.
비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다.

이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는 것이다. (로직 가독성을 높인다.)

기본값이 있는 경우 매개변수가 기본값의 타입으로 추론되기 때문에, 이때는 매개변수의 타입또한 생략가능하다.

```JS
function parseNumber(str:string,base=10){
//...
}
```

타입 정보가 있는 라이브러리에서, 콜백함수의 매개변수 타입 또한 자동으로 추론된다.

```JS

app.get('/health',(request:express.Request,response:express.Response)=>{
	response.send('OK');
})

// 이 코드 처럼 request 와 response 는 둘 다 타입 선언이 필요하지 않다.

app.get('/health',(request,response)=>{
	response.send('OK');
})

//이렇게 타입 추론으로 사용하자.

```

- 타입추론이 되지만, 타입을 명시하면 더 좋을 상황에 대해서 알아보자.

1. 객체 리터럴을 정의 할 때

```JS
const elmo:Product={
name:'elmo',
id:'1111',
price:12.3
}
```

이런 객체 리터럴을 정의할 때 타입을 명시하면 잉여 속성 체크가 동작한다.
선택적 속성이 있는 타입의 오타, 오류를 잡는 데 효과적이고,
변수가 할당되는 시점에 오류가 표시되도록 해준다. (타입을 제거하면, 객체가 사용되는 곳에서 타입 오류가 발생.)

2. 함수의 반환에 타입을 명시하여 오류 방지하기

```JS

const cache:{[ticker:string]:number}={};

function getQuote(ticker:string):Promise<number> {

if(ticker in cache){

return cache[ticker]

}

return fetch('url').then(res=>res.json())

.then(quote=>{

cache[ticker] = quote;

return quote;

});

}
```

# Item 20 - 다른 타입에는 다른 변수 사용하기

자바스크립트는 타입이 달라도 재할당 하여 사용이 가능합니다.

```JS
let id = "12";
fetchProduct(id) //string 으로 사용
id = 12;
fetchProductBySerialNumber(id)//number로 사용
```

그런나 타입스크립트에서는 **변수의 값은 바뀌어도 타입은 바뀌지 않는다**는 관점을 갖고있기 때문에 이러한 사용은 불가능합니다.

위의 코드처럼 사용하려면 타입스크립트에서는 유니온 타입으로 타입을 확장하여 사용해야 합니다.

```JS
let id:string|number ="12";

fetchProduct(id) //정상
id = 12;
fetchProductBySerialNumber(id) //정상
```

그러나 유니온 타입은 더 많은 문제가 생길 수있기 때문에, 별도의 변수를 도입하는 것이 좋습니다.
