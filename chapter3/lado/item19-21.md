# 3장. 타입 추론

## 서문

숙련된 타입스크립트 개발자는 비교적 적은 수의 구문(그러나 중요한 부분에는 사용)을 사용한다. 반면, 초보자의 코드는 불필요한 타입 구문으로 도배되어 있을 것이다.

- 3장에서는 타입 추론에서 발생할 수 있는 문제와 해법 안내
- 타입스크립트가 어떻게 타입을 추론하는지
- 언제 타입 선언을 작성해야 하는지
- 타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는 것이 필요한 상황은 언제인지

### 질문

- ‘정적 타입’과 ‘명시적 타입’의 차이?
  > 산업계에서 사용되는 프로그래밍 언어들에서는 ‘정적 타입’과 명시적 타입’이 전통적으로 같은 의미로 쓰였습니다. 그래서 C, C++, 자바에서는 타입을 직접 명시합니다. 그러나 학술계의 언어에서는 이 두 가지 타입을 결코 혼동해서 쓰지 않습니다. (107p)
- 문맥이란 무엇인지?
  > 두 번째, 타입 체커에 추가적인 **문맥**을 제공하는 것입니다(예를 들어, 함수의 매개변수로 값을 전달). 아이템 26은 타입 추론 과정에서 문맥의 역할에 대한 자세한 내용을 다룹니다. (122p)

<br />

## 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 코드의 모든 변수에 타입을 선언하는 것은 비생산적이며 형편없는 스타일이다.
- 타입 추론이 된다면 명시적 타입 구문은 필요하지 않다.

```tsx
const axis2 = 'y' // 타입은 "y"
```

```tsx
interface Product {
  id: number
  name: string
  price: number
}

// Not Good
// Product의 interface를 변경하면 일일이 바꿔줘야 함
function logProduct(product: Product) {
  const id: number = product.id
  const name: string = product.name
  const price: number = product.price
  console.log(id, name, price)
}

// Solution: 비구조화 할당문을 사용하기
function logProduct(product: Product) {
  const { id, name, price } = product
  console.log(id, name, price)
}
```

- 명시적 타입 구문이 필요한 경우
  - 매개변수의 타입 정의
    - 타입스크립트는 매개변수의 최종 사용처까지 고려해 타입을 추론하지 않는다. 타입스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정된다.
    - 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다.
    - 함수 매개변수에 타입 구문을 생략하는 경우
      - 기본값이 있는 경우
      - 타입 정보가 있는 라이브러리에서의 콜백 함수의 매개변수 타입
  - 객체 리터럴 정의
    - 이런 정의에 타입을 명시하면 잉여 속성 체크가 동작한다.
    - 잉여 속성 체크는 선택적 속성이 있는 타입의 오타 같은 오류를 잡는 데 효과적
    - 변수가 사용되는 순간이 아닌 할당하는 시점에 오류 표시
  ```tsx
  const elmo: Product = {
    name: 'Elmo',
    id: '0123',
    // Type 'string' is not assignable to type 'number'
    price: 28.99,
  }
  ```
  - 함수의 반환에 타입 명시하여 오류 방지
    - 반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.
    - 반환 타입을 명시하려면 입력 타입과 출력 타입이 무엇인지 알아야 하고, 그러면 함수에 대해 더욱 명확하게 알 수 있다.
    - 함수의 매개변수가 명명된 타입을 가질 때, 매개변수와 동일한 타입이 반환되어도 추론된 반환 타입은 다를 수 있다. 이 경우 명명된 타입으로 반환하기 위해 반환에 타입을 명시할 수 있다.

### 결론

- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.

<br />

## 아이템 20. 다른 타입에는 다른 변수 사용하기

- 변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다.
  - 타입을 바꿀 수 있는 한 가지 방법은 범위를 좁히는 것. 새로운 변수값을 포함하도록 확장하는 것이 아니라 타입을 더 작게 제한하는 것이다.
- 다른 타입에는 다른 변수를 사용하는 게 바람직하다.
  - 서로 관련이 없는 두 개의 값을 분리할 수 있다.
  - 변수명을 더 구체적으로 지을 수 있다.
  - 타입 추론을 향상시키고, 타입 구문이 불필요해진다.
  - 타입이 좀 더 간결해진다.
  - let 대신 const로 변수를 선언하게 된다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋다.
- 가려지는(shadowed) 변수

  ```tsx
  const id = '12'
  fetch(id)

  {
    const id = 12
    fetchByNumber(id)
  }
  ```

  - 동일한 변수명에 타입이 다르다면, 타입스크립트 코드는 잘 동작하지만 사람에게 혼란을 줄 수 있다. 많은 개발팀이 린터 규칙을 통해 가려지는 변수 사용을 막고 있다.

<br />

## 아이템 21. 타입 넓히기

- 런타임에 모든 변수는 유일한 값을 가진다.
- 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점엔, 변수는 ‘가능한’ 값들의 집합인 타입을 가진다.
- 타입 넓히기
  - 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다. 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻.

```tsx
interface Vector3 {
  x: number
  y: number
  z: number
}
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis]
}

let x = 'x' // 할당 시점에 넓히기가 동작해서 string으로 추론
let vec = { x: 10, y: 10, z: 30 }
getComponent(vec, x)
// Argument of type 'string' is not assignable to parameter of type '"x" | "y" | "z"'
```

- 타입 넓히기 과정을 제어할 수 있는 방법
  - const
    ```tsx
    const x = 'x' // 타입은 'x'
    const vec = { x: 10, y: 10, z: 30 }
    getComponent(vec, x)
    ```
    - 객체와 배열의 경우에는 여전히 문제가 있다.
    - 객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룬다.
    ```tsx
    const v = { x: 1 } // 타입은 {x: number}
    ```
- 타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다.
- 타입스크립트의 기본 동작을 재정의하는 3가지 방법

  - 명시적 타입 구문 제공

  ```tsx
  const v: { x: 1 | 3 | 5 } = {
    x: 1,
  } // 타입이 { x: 1|3|5 }
  ```

  - 타입 체커에 추가적인 문맥 제공 (ex) 함수의 매개변수로 값을 전달
  - const 단언문 `as const` 사용
    - 값 뒤에 `as const` 를 작성하면 최대한 좁은 타입으로 추론한다.

  ```tsx
  const v1 = {
    x: 1,
    y: 2,
  } // 타입은 { x: number; y: number; }

  const v2 = {
    x: 1 as const,
    y: 2,
  } // 타입은 { x: 1; y: number; }

  const v3 = {
    x: 1,
    y: 2,
  } as const // 타입은 { readonly x: 1; readonly y: 2; }
  ```
