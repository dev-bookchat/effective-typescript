자 또 읽어보자... 휴 -_-

## 아이템 19
- TS가 추론 하면 안작성 하는게 좋다고 ㅇㅅㅇ
    - 아 그렇네 단순한데 그거까지 하면 비용이군. TS 감사해!
    - 쬐매 복잡해도 추론을 해준다
    - 타입을 믿어라
- 이상적인 함수/메서드의 느낌적인 느낌에는 타입구문이 있지만, 지역변수에는 없다고? 야 무슨소리야...
    - 함수내에도 잘 추론하는데, 가끔 매개변수로 받는 친구는 못하니 명시적으로 적어주라
    - 타입정보가 있는 라이브러리 말곤 적어줘라
- 추론될 수 있는 경우라도 객체 리터럴, 함수 반환엔 타입명시 고려할 것ㅇㅋ, 아하 이거 오류방지구나 알겠엉.
    - 객체 리터럴은 좀 특이한데, 잘 명시해두면 남는 타입들을 (잉여속성) 잡아준다. 안그르면 처음엔 에러 안나다가 가져다 쓰는곳에서 에러남.
- 함수 반환에도 타입을 명시하면 오류를 막아줄 주 있다. TDD하기 좋다.

## 아이템 20
- 변수값은 바뀔 수 있지만 타입은 일반적으로 안바뀐다.
    - 인간의 실수다 이건
- 혼란을 막기 위해 타입이 다른값을 다룰 때 변수를 재사용하지 말 것... 뭐라는 요약이야
    - 그냥 변수 정의 각각 잘 하라는 소리
    - 스코프로 묶여버리면 쉐도잉되니까 이름 잘 정하고 잘 쓰란소리.

## 아이템 21
- TS가 넓히기를 통해 상수 타입 추론하는 법을 이해한다.
    - 초기화 시 타입 명시안하면 타입체커는 타입을 결정해야하는데, 이걸 와이딩(넓히기)라고 함. 하다가 오류도 남ㅋ
    - mixed 같은 경우 자신도 헷갈려함
    - 넓히는 오동작 방지를 위해 좁혀줘야한다.
- 동작에 영향을 줄 수 있는 const, 타입구문, 문맥, as const에 익숙해져야한다.
    - const 도 만능은 아님.
        - 특히 객체로 들어가있으면 아님
    - (1) 명시할것
    - (2) 추가 문맥 제공할 것 - 아이템26
    - (3) 타입 단언할 것 as const 로 쓰면 내부를 믿어! 라는 뜻

## 아이템 22
- 타입 좁히기 이해해야함... 누가몰라 ㅠㅠ
    - null 체크를 하자.
    - null이 아닌경우 실행도록 하고, null이 뜨면 예외처리 해주자.
    - instanseof 써서 좁히기. 
        - search instanceof RegExp
- 태그된, 구별된 유니온과 사용자 정의 타입 가드를 써서 잘 좁혀라.
    - if 구문에서 typeof로 하면 제외되지 않는 문제도 있고, null 이 object type 이라서... 
    - 또, 빈문자열은 "", 0, false 다 되는 문제가 있다.
    - 태그를 붙이자 붙여
        - 인터페이스를 상단에 붙여서 태그화 하는것
    - 커스텀 함수를 도입하는것도 방법
        - 음, 126쪽의 isInputElement 라는것을 만들어서서 사용한다.

## 아이템 23
- 속성을 제각각 추가하지말고 한번에 객체로 만들것. 안전한 타입으로 속성을 추가하려면 객제천개({...a, ...b})를 사용
- 객체에 조건부로 속성을 추가하는 방법을 익히자

## 아이템 24
- 별칭은 타입 좁히는걸 방해함, 변수에 별칭을 일관되게 사용해야함
    - 별칭남발, 제어흐름 분석 방해!!
    - 그럼 비구조화 문법으로 이 문제를 해결!!
- 비구조화 문법을 사용해 일관된 이름을 사용하는것이 좋다...
    - 흠 이부분 다시 읽어봐야지, 한글로 읽어도 모르겠네
- 함수 호출이 객체속성 타입정제를 무효화 할 수 있다. 속성보다 지역변수를 사용하면 타입 정제를 믿을 수 있다. .... 무슨 종교인가
    - 여기도 다시 읽어봐야겠다... 한글로 읽어도 뭔소린지...