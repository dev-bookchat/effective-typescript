## ✨ 타입스크립트의 타입 시스템

오늘날 자바스크립트는 어엿한 모던 프로그래밍 언어로 자리 잡았습니다. 자바스크립트 프로그래머들을 고통스럽게 하던 타입 불안정성 문제 역시 타입스크립트라는 강력한 해결책의 등장으로 안정되었습니다. 타입스크립트의 등장이 자바스크립트의 완성도를 높이는 신의 한 수가 된 셈입니다.

그렇다면 타입스크립트가 어떻게 자바스크립트의 타입 불안정성을 해결했을까요? 간단합니다. '타입'스크립트라는 이름처럼, 타입스크립트 컴파일러는 자바스크립트 코드의 타입 오류를 체크합니다.

이번 글에서는 타입스크립트의 타입 시스템을 이해하는 방법을 간단하게 요약해서 설명하겠습니다. (자세한 내용은 책 '이펙티브 타입스크립트'를 참고하세요.)

### 💡 타입이 값들의 집합이라고 생각하기

자바스크립트의 런타임에는 단 6개의 타입만 존재합니다. 하지만 타입스크립트에는 무수히 많은 종류의 타입이 있습니다. 게다가 리터럴 타입과 유니온 타입, 타입의 상속(extends) 같은 낯선 개념이 타입에 대한 이해의 걸림돌이 되기도 합니다. 이를 보다 쉽게 이해하기 위해서, 타입을 값의 집합이라고 생각해봅시다.

36.5, 7, 11, 8 등의 숫자는 number라는 집합에 들어갈 수 있습니다. 하지만 'cat'이라는 string 값은 number라는 집합에 들어갈 수 없겠죠. 집합이라고 표현했지만, 타입의 '범위'라고 이해하셔도 좋을 것 같네요.

이와 같은 관점에서 봤을 때, 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있습니다.

타입스크립트의 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현됩니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다.

타입 연산 역시 값의 집합(타입의 범위)에 적용됩니다. 또한 추가적인 속성을 가지는 값도 여전히 그 타입에 속합니다. 이 부분에선 간단한 예시 코드를 보겠습니다.

```
interface Person {
name: string;
}

interface Lifespan {
birth: Date;
death?: Date;
}

type PersonSpan = Person & Lifespan;
```

언뜻 봤을 때는 Person과 Lifespan 인터페이스는 공통으로 가지는 속성이 없기 때문에 PersonSpan 타입이 공집합(never 타입)처럼 보일 수 있습니다. PersonSpan의 범위를 오렌지색으로 표현한다면 아래 그림 같을 거라고 생각하기 때문이죠.

![](https://velog.velcdn.com/images/perfumellim/post/15bfce53-37bb-449e-9fb8-403cb832b7a2/image.jpg)

하지만 실제로는 다음 그림에 가깝습니다.

![](https://velog.velcdn.com/images/perfumellim/post/fb620a37-d963-4b43-851d-275bb5cbbdf4/image.jpg)

그래서 아래와 같은 코드가 정상적으로 작동합니다.

```
const ps: PersonSpan = {
name: 'Hedy Lamarr',
birth: new Date('1914/11/09'),
death: new Date('2000/01/19').
};
```

(앞의 세 가지보다 더 많은 속성을 가지는 값도 PersonSpan 타입에 속합니다.)

타입이 집합이라는 관점은 이외의 다른 개념들도 명확하게 이해할 수 있도록 돕습니다. 'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입' 등의 말은 결국 A는 B의 부분 집합이라는 뜻입니다.

### 💡 타입 공간과 값 공간의 심벌 구분하기

타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 합니다. 타입스크립트의 심벌(symbol)이 타입 공간이나 값 공간 중 한 곳에 존재하기 때문입니다. 이름이 같더라도 심벌이 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 이 부분이 혼란스러울 수 있습니다.

모든 값은 타입을 가지지만, 타입은 값을 가지지 않습니다. type과 interface 같은 키워드는 타입 공간에만 존재합니다.

class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있습니다.

> 💛 조금 다른 이야기인데요, 타입스크립트에서 enum을 되도록 사용하지 않는 것이 좋다고 합니다. 이에 관한 자세한 내용은 [이 글](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/)을 참조하세요.

typeof, this 그 외의 여러 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있습니다.

그래서 타입스크립트 코드가 잘 동작하지 않는다면 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 큽니다. 이를 구분하는 방법을 터득하기 위해서 타입스크립트 플레이그라운드를 활용해 개념을 잡으면 좋을 것 같네요!
